#Redd's Art ( Reverse Engineering ) Writeup

At first i tried to run the binary and the output seems like conversation which asked for input several times. If we send `no` as input for 2 times ( after sending name ) the output will be string like flag but it just a fake flag ( uiuctf{v3Ry_r341_@rTT} ). 

After that i tried to look at main function and didn't find anything useful. There is `gets` function called in main but this is `reversing` challenge not pwn challenge and the result from `checksec` made it more obvious.
```
[*] '/home/kosong/ctf/uiuctf_2020/ReddsArt'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```
then i tried to look at another function and found something fishy. That function is sub_A5A().
```
char *sub_A5A()
{
  char *result; // rax
  int i; // [rsp+0h] [rbp-10h]
  char v2; // [rsp+4h] [rbp-Ch]

  v2 = sub_91A();
  result = byte_973;
  for ( i = 0; i <= 230; ++i )
  {
    result = &byte_973[i];
    *result ^= v2;
  }
  return result;
}
```
and here is function sub_91A.
```
__int64 sub_91A()
{
  unsigned int v1; // [rsp+8h] [rbp-18h]
  int i; // [rsp+Ch] [rbp-14h]

  v1 = 0;
  for ( i = 0; i < strlen(s); ++i )
    v1 += s[i];
  return v1;
}
```
s = "uiuctf{v3Ry_r341_@rTT}" , so we can call that function using `gdb` or reconstruct that code then run it.
```
gefâž¤  p (int) 0x55555555491a()
$1 = 0x81e
```
now we know the return value from sub_91A, so the next step is trying to reconstruct sub_A5A function , because we cannot call it directly ( segmentation fault ).
```
#solver_redds.py
a=[0x4b,0x56,0x97,0xfb,0x4d,0x56,0x9d,0xf2,0x36,0x56,0xd9,0x5b,0xf6,0x17,0x1e,0x1e,0x1e,0x56,0x95,0x5b,0xf6,0x11,0xa8,0x1e,0x56,0x11,0xa0,0xde,0x56,0x1f,0x5b,0xf6,0x56,0x95,0x5b,0xf6,0x11,0xa8,0x1e,0x96,0x5b,0xc5,0xd9,0x5b,0xc2,0x1e,0x1e,0x1e,0x1e,0xf5,0x2c,0x56,0x95,0x0b,0x65,0x08,0x3e,0x1e,0x95,0x5b,0xc2,0x56,0x86,0x56,0x1f,0xce,0x11,0xa8,0x1e,0x97,0xdc,0x11,0xa8,0x5b,0xc5,0x93,0x12,0x1c,0x56,0x95,0x0b,0x7e,0x08,0x3e,0x1e,0x95,0x5b,0xc2,0x56,0x86,0x56,0x1f,0xce,0x97,0xd4,0x96,0x0e,0x9d,0x5b,0xc2,0x1f,0x95,0x5b,0xc2,0x56,0x7d,0xc6,0x56,0x95,0x1b,0x5d,0x08,0x3e,0x1e,0x56,0x97,0xd9,0xf6,0xad,0xe3,0xe1,0xe1,0x56,0x27,0xdd,0x6c,0xaa,0xa6,0x1e,0x1e,0x1e,0x1e,0xf6,0x00,0xe1,0xe1,0xe1,0x97,0x5b,0xfa,0xd9,0x5b,0xfe,0x1e,0x1e,0x1e,0x1e,0xf5,0x2e,0x56,0x95,0x0b,0x07,0x08,0x3e,0x1e,0x95,0x5b,0xfe,0x56,0x86,0x56,0x1f,0xce,0x11,0xa8,0x16,0x95,0x5b,0xfa,0x97,0xd8,0x56,0x95,0x0b,0x1c,0x08,0x3e,0x1e,0x95,0x5b,0xfe,0x56,0x86,0x56,0x1f,0xce,0x2f,0xef,0x97,0xd4,0x96,0x0e,0x9d,0x5b,0xfe,0x1f,0x95,0x5b,0xfe,0x56,0x7d,0xc6,0x56,0x95,0x1b,0xfd,0x0b,0x3e,0x1e,0x56,0x97,0xd9,0xf6,0x4d,0xe3,0xe1,0xe1,0x56,0x27,0xdd,0x6c,0xa8,0x8e,0x56,0x9d,0xda,0x36,0x45,0x43,0xdd] // byte_973
key=0x81e
result=""
for i in a:
    result+=chr((i^key)&0xff)
print result
```
The result is weird and finally i realized that the result is `machine code` . We can convert it to assembly language using `ndisasm`. 

`python solver_redds.py | ndisasm -u -b 64 -`
here is the result
```
00000000  55                push rbp
00000001  4889E5            mov rbp,rsp
00000004  53                push rbx
00000005  4883EC28          sub rsp,byte +0x28
---------------------------------------------------
000000E4  5B                pop rbx
000000E5  5D                pop rbp
000000E6  C3                ret
000000E7  0A                db 0x0a
```
so the next step i do is try to patch it by scripting with python. Find the correct offset using hex editor then patch it! 
```
#solver_redds.py
f=open("ReddsArt","r")
b=f.read()
key=0x81e
c=""
for i in range(len(b)):
    if(i>0x972 and i<0xa5a):
        c+=chr((ord(b[i])^key)&0xff)
    else:
        c+=b[i]
print c
```
then redirect the output to file 
`python solver_redds.py > newredds`
After that i tried to run it and it is work normally and then i tried to open it in IDA. IDA will recognize byte_973 as valid function ( after we patched it ) . 
```
size_t sub_973()
{
  size_t result; // rax
  int i; // [rsp+Ch] [rbp-24h]
  int j; // [rsp+10h] [rbp-20h]
  char v3; // [rsp+14h] [rbp-1Ch]

  for ( i = 0; i < strlen(off_202028); ++i )
    off_202028[i] += 3;
  v3 = sub_91A();
  for ( j = 0; ; ++j )
  {
    result = strlen(off_202028);
    if ( j >= result )
      break;
    off_202028[j] ^= v3;
  }
  return result;
}
```
So the final step is reconstruct the sub_973 function and got the flag!
```
off_202028="hthzgubI>*ww7>z+Ha,m>W,7z+hmG"
flag=""
for i in off_202028:
  flag+=chr((ord(i)+3)^0x1e)
print flag
```

## Flag : uiuctf{R_3dd$_c0Uz1n_D1$c0unT}